{% import "./macros/formGroup.twig" as formGroup %}

<template>
<div>
  {% verbatim %}
   <div>{{state}}</div>
   <div>{{computedState}}</div>
{% endverbatim %}

    <el-form :model="model" >
        {{ formGroup.renderSet("config.row.properties", "model", 1,3, 'el-col', 'template') }}
    </el-form>
</div>
</template>

<script type="module">
  import { formModel } from 'http://localhost:7002/public/expose/main.js';



function findPathsToKey(options) {
  let results = [];

  (function findKey({
                      key,
                      obj,
                      pathToKey,
                    }) {
    const oldPath = `${pathToKey ? pathToKey + "." : ""}`;
    if (typeof obj === "object" && obj.hasOwnProperty(key)) {
      results.push(`${oldPath}${key}`);
      // return;
    }

    if (obj !== null && typeof obj === "object" && !Array.isArray(obj)) {
      for (const k in obj) {
        if (obj.hasOwnProperty(k)) {
          if (Array.isArray(obj[k])) {
            for (let j = 0; j < obj[k].length; j++) {
              findKey({
                obj: obj[k][j],
                key,
                pathToKey: `${oldPath}${k}[${j}]`,
              });
            }
          }

          if (obj[k] !== null && typeof obj[k] === "object") {
            findKey({
              key,
              pathToKey: `${oldPath}${k}`,
            });
          }
        }
      }
    }
  })(options);

  return results;
}


  export default {
    props: {
      modelValue: null,
    },
    emits: [
      'model:update',
    ],
    mounted() {
      this.$emit('init', this);
    },
    setup(props, { emit }) {
      const { ref, inject, watch } = global.Vue;
      const globalStore = inject('globalStore');
      const tableData = ref([]);

      const config = ZY.JSON5.parse(`{{source}}`);
      console.log('config', config)

      const obj = formModel.createFormModel(config.row);

    let computedLinks = {
    }

    function formDefTravase(formDef = {}, computedLinks) {
      if (formDef.type === 'object') {
        Object.entries(formDef.properties)
                .forEach(([ key, formDefProp ]) => {
                  if (formDefProp.type !== 'array') {
                    if (formDefProp.computedProp) {
                      const linked = formDefProp.computedProp
                      if (!computedLinks[linked]) {
                        computedLinks[linked] = []
                      }
                      computedLinks[linked].push(key)
                    }
                  } else {
                    formDefTravase(formDefProp.items, computedLinks);
                  }
                });
      }
    }

    formDefTravase(config.row, computedLinks);
    // console.log(computedLinks)

    let ret = {
    }
    let computed = {}
    for (let key in config.computed) {
      computed[key] = new Function('model', 'options',`
        function VAL(v, defaultVal) {
          return ZY.lodash.get(model, v, defaultVal)
        }
        return () => {
          // console.log('computed ${key} build', options)
          options.beforeBuild('${key}')
          return ${config.computed[key]}
        }
      `)
    }

    function autoVal({obj, key, computedVal = function() {}} = {}) {
      let paths =  findPathsToKey({obj, key})

      for (let k = 0; k < paths.length; k++) {
        let target;
        let p =  paths[k].replace(key, '')
        if (p.endsWith('.')) {
          p = p.slice(0, -1)
        }
        if (p.trim() === '') {
          target = model
        } else {
          target = ZY.lodash.get(model, p)
        }
        target[key] = computedVal()
      }
    }

    let model = null
    ret = globalStore.run(config.service, 'initModel', {
      plain: obj,
      computed,
      callback: {
        onComputedChange(key, newVal) {
          // console.log('onComputedChange', key, newVal)

          let findKeys = computedLinks[key]
          if (Array.isArray(findKeys)) {
            for (let k = 0; k < findKeys.length; k++) {
              console.log('findKeys[k]', findKeys[k])
              autoVal({
                obj: model,
                key: findKeys[k],
                computedVal() {
                  return newVal
                }
              })
            }
          }
          
          // model['linkName'] = newVal
        }
      }
    })
    // console.log('ret', config, ret)

    model = ret.model

    watch(model, newVal => {
      // console.log('model.content', newVal)
      emit('model:update', newVal);
    });

    let templateFun = ''
    for (let funName in ZY.lodash) {
      templateFun = templateFun + `
        function ${funName}(...args) {
          return ZY.lodash.${funName}(...args)
        }
      `
    }

    function dxValue(v, ...args) {
      let fun = new Function('valueTemplate', '$root', `
        ${templateFun}

        function VAL(v, defaultVal) {
          return ZY.lodash.get($root.model, v, defaultVal)
        }
        return eval(valueTemplate)
      `)
      return fun(v, ret)
    }

    return {
      config,
      model,
      tableData,
      state: ret.model,
      computedState: ret.computedModel,
      defaultTo: ZY.lodash.defaultTo,
      get: ZY.lodash.get,
      dxValue
    };
  },
};
</script>
