{% import "./macros/formGroup.twig" as formGroup %}
{% import "./macros/attr.twig" as attr %}

<template>
<div>
  {% verbatim %}
<div>
   <div>{{state}}</div>
   <div>{{computedState}}</div>
</div>
{% endverbatim %}
    <el-form ref="formCom" :model="model" {{ attr.parseKeyValue(CONFIG.ui.attrs) }}>
      {{ formGroup.renderSet("config.row.properties", "model", 1,6, 'el-col', 'template') }}
      <slot-com :defs="slotContent" name="default"></slot-com>
    </el-form>
</div>
</template>

<script type="module">
  import { formModel, comHelper } from '{{ APP_CONFIG.server_origin }}/public/expose/main.js';

  export default {
    props: {
      modelValue: null,
      render: null
    },
    emits: [
      'model:update',
    ],
    mounted() {
      this.$emit('init', this);
    },
    created() {
      const { provide } = global.Vue;
      provide('curFormCon', this)
    },
    setup(props, { emit }) {
      const { ref, inject, watch, getCurrentInstance } = global.Vue;
      const { useStore } = global.Vuex
      let store = useStore()

      const globalStore = inject('globalStore');
      const curFormCon = getCurrentInstance().ctx;
      // console.log('curFormCon', curFormCon)

      // let comManager = inject('comManager')
      // function callComManager(name,e ) {
      //   comManager.context.sendEvent(name,e)
      // }

      // console.log('globalStore', globalStore)

      const config = ZY.JSON5.parse(`{{CONFIG_SOURCE_JSON5}}`);
      // console.log('config', config)

      const obj = formModel.createFormModel(config.row);

      let templateFun = ''
      for (let funName in ZY.lodash) {
        templateFun = templateFun + `
        function ${funName}(...args) {
          return ZY.lodash.${funName}(...args)
        }
      `
      }

      let commonFun = `
        ${templateFun}

        function ZY_hour_between_2_date(date1, date2) {
          if (date1 && date2) {
            return ZY.Time.subtract2Date(date1, date2).asHours()
          }
          return null
        }

        function ZY_floor(v, presion) {
          let ret = floor(v, presion)
          if (ret === 0) {
            return ''
          }
          return ret
        }

        function LENGTH(v) {
          if (v && v.length) {
            return v.length
          }
          return -1
        }

        function VAL(v, defaultVal) {
          return ZY.lodash.get($root, v, defaultVal)
        }
      `

    let computedLinks = {
    }

    function formDefTravase(formDef = {}, computedLinks) {
      if (formDef.type === 'object') {
        Object.entries(formDef.properties)
                .forEach(([ key, formDefProp ]) => {
                  if (formDefProp.type !== 'array') {
                    if (formDefProp.computedProp) {
                      const linked = formDefProp.computedProp
                      if (!computedLinks[linked]) {
                        computedLinks[linked] = []
                      }
                      computedLinks[linked].push({
                        key
                      })
                    }
                  } else {
                    formDefTravase(formDefProp.items, computedLinks);
                  }
                });
      }
    }

    formDefTravase(config.row, computedLinks);
    // console.log(computedLinks)

    let ret = {
    }
    let computed = {}
    for (let key in config.computed) {
      computed[key] = new Function('model', 'options', `
        let $root = options.context.ctx
        let $rootStore = options.context.store

        ${commonFun}

        function MODEL(v, defaultVal) {
          return ZY.lodash.get(model, v, defaultVal)
        }

        function ROOT_STATE(v, defaultVal) {
           return ZY.lodash.get($rootStore.state, v, defaultVal)
        }

        return () => {
          // console.log('computed ${key} build', options)
          options.beforeBuild('${key}')
          return ${config.computed[key]}
        }
      `)
    }


    let model = null
    ret = globalStore.run(config.service, 'initModel', {
      plain: obj,
      computed,
      callback: {
        onComputedChange(key, newVal) {
          // console.log('onComputedChange', key, newVal)
          let findKeys = computedLinks[key]
          if (Array.isArray(findKeys)) {
            findKeys.forEach(findKeyItem => {
              comHelper.autoVal({
                obj: model,
                key: findKeyItem.key,
                base: model,
                computedVal() {
                  return newVal
                }
              })
            })
          }
        }
      },
      context: {
        ctx: curFormCon,
        store
      }
    })
    // console.log('ret', config, ret)

    model = ret.model

    watch(model, newVal => {
      // console.log('model.content', newVal)
      emit('model:update', newVal);
    });


    //   function dxValue(v, ...args) {
    //     let fun = new Function('valueTemplate', '$root', `
    //     ${templateFun}
    //     function LENGTH(v) {
    //       if (v && v.length) {
    //         return v.length
    //   function dxEval(v, context) {
    //     let trueContext = context ? context : this;
    //     let fun = new Function('valueTemplate', 'options', `
    //     // let $config = $context.config
    //     let $root = options.$root
    //     let $rootStore = options.store
    //
    //     ${commonFun}
    //
    //     function ROOT_STATE(v, defaultVal) {
    //       return ZY.lodash.get($rootStore.state, v, defaultVal)
    //     }
    //     return -1
    //   }
    //   function VAL(v, defaultVal) {
    //     return ZY.lodash.get($root, v, defaultVal)
    //   }
    //   function MODEL(v, defaultVal) {
    //     return ZY.lodash.get($root.model, v, defaultVal)
    //   }
    //   return eval(valueTemplate)
    //           `)
    //   return fun(v, ret)
    // }

      function dxEval(v, context) {
        let trueContext = context ? context : this;
        // console.log('trueContext', trueContext)
        let fun = new Function('valueTemplate', 'options', `
            // let $config = $context.config
            let $root = options.$root
            let $rootStore = options.store

           ${commonFun}

           function ROOT_STATE(v, defaultVal) {
             return ZY.lodash.get($rootStore.state, v, defaultVal)
           }

            function VAL(v, defaultVal) {
              return ZY.lodash.get($root, v, defaultVal)
            }

            function MODEL(v, defaultVal) {
              return ZY.lodash.get($root.model, v, defaultVal)
            }

            return eval(valueTemplate)
          `)

        return fun(v, {
          $root: trueContext,
          store
        })
      }

    function dxValue(v) {
        return dxEval(v, this)
    }

    let formCom = ref(null)
    async function callCom(methodName, ...args) {
        if (!formCom.value) {
          throw new Error('formCom.value null')
        }
     return  await ZY.awaitTo(formCom.value[methodName](...args))
    }

    let instanse = {
      config,
      model,
      state: ret.model,
      computedState: ret.computedModel,
      defaultTo: ZY.lodash.defaultTo,
      get: ZY.lodash.get,
      dxValue,
      dxEval,
      formCom,
      callCom
    };

      instanse.slotContent = (function() {
        if (props.render) {
          return props.render()
        }
        return {
          default: []
        }
      })()

      instanse.getState = function() {
        let res = {}
        for (let k in ret.model) {
          res[k] = ret.model[k]
        }
        for (let k in ret.computedModel) {
          res[k] = ret.computedModel[k].value
        }
        return {
          val: res,
          toRaw() {
            return ZY.JSON5.parse(ZY.JSON5.stringify(res))
          }
        }
      }

      instanse.getRawState = function() {
        return instanse.getState().toRaw()
      }

      return instanse
  },
};
</script>
