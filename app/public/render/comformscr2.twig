{% import "./macros/formGroup.twig" as formGroup %}
{% import "./macros/attr.twig" as attr %}

<style>
  .z-form__object {
    flex-direction: column;
  }
</style>

<template>
<div class="http-com comformscr2">
  {% for part in CONFIG.parts %}
    {% set pathKey = "parts." ~ part.name %}
<div v-if="{{pathKey}}"
     :hidden="!debug"
>
   <div hidden>{% verbatim %}{{{% endverbatim %} {{pathKey}}.model {% verbatim %}}}{% endverbatim %}</div>
  <div>{% verbatim %}{{{% endverbatim %} {{pathKey}}.computedModel {% verbatim %}}}{% endverbatim %}</div>
{#   <div>{{parts.form.computedModel}}</div>#}
</div>
  {% endfor %}
  {% for part in CONFIG.parts %}
    {% set partConfigKey = 'config.parts[' ~ loop.index0 ~ '].def' %}
    {% set pathKey = "parts." ~ part.name %}
    {% set pathSKey = "'parts." ~ part.name ~ "'" %}
    {% set modelKey = pathKey ~ ".model"  %}
    {% if part.type == 'form' %}

{#      {% verbatim %}{{ {% endverbatim %} parts {% verbatim %} }} {% endverbatim %}#}
      <el-form class="z-form http-com-part http-com-part__{{ part.name }}"
               :ref="{{ pathKey }}.initEl" :model="{{ pathKey }}.model" {{ attr.parseKeyValue(part.def.ui.attrs) }}>
{#{{ modelKey }}#}
{#        {{ partConfigKey }}#}
{#            {% verbatim %}{{ {% endverbatim %} {{ modelKey }} {% verbatim %} }} {% endverbatim %}#}

        <slot-com :defs="slotContent" :attrs="{parts}"
                  :binds="{name: '{{ part.name }}', process: '{{ CONFIG.process}}' }"
                  name="form_before"></slot-com>
        {{ partStr[part.name] }}
        <slot-com :defs="slotContent" :attrs="{parts}"
                  :binds="{name: '{{ part.name }}', process: '{{ CONFIG.process}}' }"
                  name="form_after"></slot-com>
      </el-form>
    {% endif %}
    {% if part.type == 'table' %}
      {% verbatim %}{{ {% endverbatim %} {{ pathKey }}.model {% verbatim %} }} {% endverbatim %}

      <slot-com :defs="slotContent" :attrs="{parts}"
                :binds="{name: '{{ part.name }}', process: '{{ CONFIG.process}}' }"
                name="table_prev"></slot-com>
      {{ partStr[part.name] }}

{#      <el-form class="z-form http-com-part http-com-part__{{ part.name }}"#}
{#           :ref="{{ pathKey }}.initEl" :model="{{ pathKey }}.model" {{ attr.parseKeyValue(part.def.ui.attrs) }}>#}
{#      {{ partStr[part.name] }}#}
{#  </el-form>#}
{#      <el-table class="z-table  http-com-part http-com-part__{{ part.name }}"#}
{#                :ref="{{ pathKey }}.initEl" :data="{{ pathKey }}.model.records"  stripe="true"#}
{#                border="true" {{ attr.parseKeyValue(part.def.ui.attrs) }}>#}
{#        {% for key,record in part.def.properties.records.items.properties %}#}
{#          {% set configKey = partConfigKey ~ '.records.items.properties.' ~ key %}#}
{#          <div v-html="get({{ configKey }}, 'ui.label', '')">1111</div>#}
{#          <el-table-column prop="{{ key }}"#}
{#                           :label="get({{ configKey }}, 'ui.label', '')"#}
{#                  {{ attr.parseUIAttrs(record.ui, configKey) }}#}
{#          >#}
{#            {% if record.useSlotTemplate %}#}
{#              <template  #default="scope">#}
{#                {{ formGroup.tag(record.template) }}#}
{#                <slot-com :defs="slotContent" :attrs="{parts, scope}" name="actions"></slot-com>#}
{#              </template>#}
{#            {% else %}#}
{#              <template #default="scope">#}
{#                {% verbatim %}{{ {% endverbatim %} scope.row[scope.column.property] {% verbatim %}}}{% endverbatim %}#}
{#              </template>#}
{#            {% endif %}#}
{#          </el-table-column>#}
{#        {% endfor %}#}
{#      </el-table>#}
{#      <el-pagination#}
{#              background#}
{#              layout="prev, pager, next"#}
{#              :current-page="{{ pathKey }}.model.page"#}
{#              :page-size="{{ pathKey }}.model.limit"#}
{#              :total="{{ pathKey }}.model.total">#}
{#      </el-pagination>#}
    {% endif %}
  {% endfor %}
</div>
</template>

<script type="module">
  import { comHelper, formModel } from '{{ APP_CONFIG.server_origin }}/public/expose/main.js';

  export default {
    props: {
      debug: {
        type: Boolean
      },
      modelValue: null,
      render: null
    },
    emits: [
      'model:update',
    ],
    data() {
      return {
        comUUID: ZY.nid(),
        comManager: null,
        currentProcess: '{{ CONFIG.process }}',
      }
    },
    mounted() {
      const { ref, inject, watch, getCurrentInstance } = global.Vue;
      this.$emit('init', this);

      let comManager = inject('comManager')
      this.$nextTick(()=> {
        comManager.context.sendEvent('http-component:com:mounted', {
          httpComponentComContext: this,
          comManager,
          httpComponentContext: comManager.context,
        })
        comManager.context.sendEvent(`${comManager.context.is}@http-component:com:mounted`, {
          httpComponentComContext: this,
          comManager,
          httpComponentContext: comManager.context,
        })
        comManager.register(this, this.comUUID)
        comManager.context.setCurrentChild(this.comUUID)
        // console.log(comManager)
      })
      this.comManager = comManager
    },
    beforeUnmount() {
      const { ref, inject, watch, getCurrentInstance, toRaw } = global.Vue;
      let comManager = this.comManager
      // console.log(comManager)
      comManager.destory(this.comUUID)
    },
    created() {
      const { provide } = global.Vue;
      provide('curFormCon', this)
    },
    setup(props, { emit }) {



      const config = ZY.JSON5.parse(`{{CONFIG_SOURCE_JSON5}}`);
      const { ref, inject, watch, getCurrentInstance, toRaw } = global.Vue;
      const { useStore } = global.Vuex
      let store = useStore()

      const globalStore = inject('globalStore');
      const curFormCon = getCurrentInstance().ctx;


      function initPart(partDef) {
        let rowDef = partDef.def
        let computedLinks = {
        }
        let reflectMap = new Map()
        // computed start
        let ret = {
        }
        let computed = {}
        for (let key in partDef.computed) {
          /**
           * 计算computed的function
           * @type {Function}
           */
          computed[key] = new Function('model', 'options', `
            let $root = options.context.ctx
            let $rootStore = options.context.store
            let A = options.context.app

            ${commonFun}

            function MODEL(v, defaultVal) {
              return ZY.lodash.get(model, v, defaultVal)
            }

            function ROOT_STATE(v, defaultVal) {
               return ZY.lodash.get($rootStore.state, v, defaultVal)
            }

            return () => {
              // console.log('computed ${key} build', options)
              options.beforeBuild('${key}')
              return ${partDef.computed[key]}
            }
        `)
        }
        // computed end
        let model = null
        const obj = formModel.createFormModel(rowDef);
        formDefTravase(rowDef, computedLinks, {
          path: '',
          reflectMap
        });


        // console.log('rowDef', rowDef, computedLinks)
        ret = globalStore.run(partDef.service, 'initModel', {
          plain: obj,
          computed,
          callback: {
            onComputedChange(key, newVal) {
              // console.log('onComputedChange', key, newVal)
              let findKeys = computedLinks[key]
              if (Array.isArray(findKeys)) {
                findKeys.forEach(findKeyItem => {
                  let target = ZY.lodash.get(model, findKeyItem.parentKey)
                  // console.log(findKeyItem, target)
                  if (findKeyItem.parentType === 'array') {
                    // target是数组
                    // const obj = formModel.createFormModel(findKeyItem.parentDef);
                    // target.forEach(item => {
                    //   for (let k in obj) {
                    //     if (!item.hasOwnProperty(k)) {
                    //       item[k] = obj[k]
                    //     }
                    //   }
                    // })
                  }
                  // console.log(Array.isArray(target), model)
                  comHelper.autoVal({
                    obj: model,
                    key: findKeyItem.key,
                    base: model,
                    computedVal() {
                      if (findKeyItem.valTpl) {
                        // console.log(findKeyItem.valTpl)
                        let context = {
                          A: globalThis.getApp(),
                          $VAL: newVal,
                          L: ZY.lodash
                        }
                        return ZY_EXT.eval5(findKeyItem.valTpl, context)
                      }
                      return newVal
                    }
                  })
                })
              }
            }
          },
          context: {
            ctx: curFormCon,
            app: globalThis.getApp(),
            store
          }
        })
        model = ret.model


        function forceUpdate(parent, key, newVal) {
          parent[key] = newVal
          let obj = {
            key,
            newVal,
            config,
            model
          }
          // console.log('sdsdsdsds')
          curFormCon.comManager.context.sendEvent('model:update', obj)
        }
        ret.forceUpdate = forceUpdate

        function watchHandler(key) {
          return function(newVal) {
            // console.log('model.content', newVal)
            let obj = {
              key,
              newVal,
              config,
              model
            }
            emit('model:update', obj);
            curFormCon.comManager.context.sendEvent('model:update', obj)
          }
        }
        function attachModelWatcher(model, parentPath, subModel) {
          if (typeof subModel === 'object') {
            for (let key in subModel) {
              let tureKey = parentPath ? `${parentPath}.${key}` : key
              if (Array.isArray(subModel[key])) {
                subModel[key].forEach((subItem, subIndex) => {
                  // console.log(subItem, subIndex)
                  attachModelWatcher(model, `${tureKey}[${subIndex}]`, subItem)
                })
              } else {
                // console.log('model', tureKey,  ZY.lodash.get(model, tureKey))
                watch(() => ZY.lodash.get(model, tureKey), watchHandler(tureKey));
              }
            }
          }
        }

        attachModelWatcher(model, '', model)

        let cachedModel = ''
        watch(model, (newVal, oldVal) => {
          let newObj = toRaw(newVal)
          if (!cachedModel) {
            cachedModel = '{}'
          } else {
          //
          }
          let oldObj = ZY.JSON5.parse(cachedModel)
          let diffed = ZY.diff(oldObj, newObj)
          // console.log('model.content', reflectMap, newObj, oldObj, diffed)
          reflectMap.forEach((arr, key) => {
            // console.log(key, value)
            // console.log(arr)
            let hasDiffedChange = ZY.lodash.get(diffed, key)
            if (hasDiffedChange) {
              // for (let [diffedChangedKey, diffedChangedValue] of Object.entries(hasDiffedChange)) {
              //
              // }
              ZY.lodash.each(hasDiffedChange, (svalue, skey) => {
                if (typeof svalue !== 'undefined') {
                  let fullPath = key + '.' + skey
                  // console.log(`${fullPath} changed`, svalue)
                  let modelTarget = ZY.lodash.get(model, fullPath)
                  // let changed = {}
                  arr.forEach((arrItem) => {
                    let {key,reflect, valTpl}  = arrItem
                    if (valTpl) {
                      modelTarget[key] = ZY_EXT.eval5(valTpl, {
                        A: globalThis.getApp(),
                        $VAL: modelTarget[reflect],
                        L: ZY.lodash,
                      })
                    }else {
                      modelTarget[key] = modelTarget[reflect]
                    }
                  })
                }
              })
            }
            // console.log(key, hasDiffedChange)
          })

          cachedModel = ZY.JSON5.stringify(newObj)
          // emit('model:update', newVal);

          // console.log(curFormCon.comManager.context)
          curFormCon.comManager.context.sendEvent('model:update:all', {
            newVal,
            diffed,
            config,
            model
          })
        });
        ret.el = ref(null)
        ret.initEl = function(ctx) {
          // console.log(ctx)
          ret.el.value = ctx
        }

        async function callEl(methodName, ...args) {
          if (!ret.el ) {
            throw new Error('formCom.value null')
          }
          // console.log(partKey, parts, part.el)
          let elRef = ret.el.value
          if (!elRef) {
            throw new Error('formCom.value null')
          }
          return await ZY.awaitTo(elRef[methodName](...args))
        }
        ret.callEl = callEl

        ret.getState = function() {
          let res = {}
          for (let k in ret.model) {
            res[k] = ret.model[k]
          }
          for (let k in ret.computedModel) {
            res[k] = ret.computedModel[k].value
          }
          return {
            val: res,
            toRaw() {
              return ZY.JSON5.parse(ZY.JSON5.stringify(res))
            }
          }
        }

        ret.setModel = function(path, value) {
          ZY.lodash.set(ret.model, path, value)
        }

        /**
         * arr自动添加
         * @param path
         */
        ret.arrAppend = function(path) {
          let arr = ZY.lodash.get(ret.model, path)
          if (Array.isArray(arr)) {
            // if (arr[0]) {
            //   let type = typeof arr[0]
            //   if (type === 'object') {
            //     arr.push({})
            //   }
            // }
            arr.push({})
          }
          return arr[arr.length - 1]
        }

        /**
         * arr删除
         * @param path
         * @param index
         * @param deleteCount
         */
        ret.appSplice = function(path, index, deleteCount = 1) {
          let arr = ZY.lodash.get(ret.model, path)
          if (Array.isArray(arr)) {
            arr.splice(index, deleteCount)
          }
          // console.log(arr)
        }

        ret.getModel = function() {
          let res = {}
          for (let k in ret.model) {
            res[k] = ret.model[k]
          }
          return res
        }

        ret.getRawState = function(...args) {
          return ret.getState(...args).toRaw()
        }
        return ret
      }

      function formDefTravase(formDef = {}, computedLinks, ext = {path: '', reflectMap: {}}) {

        if (formDef.type === 'object') {
          Object.entries(formDef.properties)
                  .forEach(([ key, formDefProp ]) => {
                    let truePath = ext.path ? `${ext.path}.${key}` : key

                    if (formDefProp.type !== 'array') {
                      if (formDefProp.type === 'object') {
                        // console.log('oh this is a big formDefTravase handle object', {
                        //   truePath,
                        //   formDef
                        // })
                        formDefTravase(formDefProp, computedLinks, {
                          path: truePath,
                          parentDef: formDef.properties[key],
                          parentType: 'object',
                          reflectMap: ext.reflectMap
                        });

                      } else {
                        if (formDefProp.computedProp) {
                          const linked = formDefProp.computedProp;
                          if (!computedLinks[linked]) {
                            computedLinks[linked] = [];
                          }
                          computedLinks[linked].push({
                            key,
                            parentType: ext.parentType ?? '',
                            parentKey: ext.path,
                            parentDef: ext.parentDef ?? {},
                            valTpl: formDefProp.computedTpl,
                            reflectMap: ext.reflectMap
                          });
                        }
                        if (formDefProp.reflect) {
                          let target = []
                          let spath = ext.path
                          let obj = {
                            key,
                            reflect: formDefProp.reflect,
                            valTpl: formDefProp.reflectTpl,
                          }
                          if (ext.reflectMap.has(spath)) {
                            target = ext.reflectMap.get(spath)
                          }
                          target.push(obj)
                          ext.reflectMap.set(spath, target)
                        }
                      }
                    } else {
                      formDefTravase(formDefProp.items, computedLinks, {
                        path: truePath,
                        parentDef: formDef.properties[key].items,
                        parentType: 'array',
                        reflectMap: ext.reflectMap
                      });
                    }
                  });
        }
      }

      let templateFun = ''
      for (let funName in ZY.lodash) {
        templateFun = templateFun + `
        function ${funName}(...args) {
          return ZY.lodash.${funName}(...args)
        }
      `
      }

      let commonFun = `
        ${templateFun}

        function ZY_hour_between_2_date(date1, date2) {
          if (date1 && date2) {
            return ZY.Time.subtract2Date(date1, date2).asHours()
          }
          return null
        }

        function ZY_floor(v, presion) {
          let ret = floor(v, presion)
          if (ret === 0) {
            return ''
          }
          return ret
        }

        function LENGTH(v) {
          if (v && v.length) {
            return v.length
          }
          return -1
        }

        function VAL(v, defaultVal) {
          return ZY.lodash.get($root, v, defaultVal)
        }
      `

      // console.log('curFormCon', curFormCon)
      // function callComManager(name,e ) {
      //   comManager.context.sendEvent(name,e)
      // }

      // console.log('globalStore', globalStore)

      function dxEval(v, $root, context) {
        let trueContext = context ? context : this;
        // console.log(trueContext)
        let fun = new Function('valueTemplate', 'options', `
          // let $config = $context.config
          let $root = options.$root
          let $rootStore = options.store
          let A = options.app

         ${commonFun}

         function ROOT_STATE(v, defaultVal) {
           return ZY.lodash.get($rootStore.state, v, defaultVal)
         }

          function VAL(v, defaultVal) {
            return ZY.lodash.get($root, v, defaultVal)
          }

          function MODEL(v, defaultVal) {
            return ZY.lodash.get($root.model, v, defaultVal)
          }

          return eval(valueTemplate)
        `)

        return fun(v, {
          $root,
          context: trueContext,
          app: globalThis.getApp(),
          store
        })
      }

      function dxValue(partContext, v) {
        // console.log('this', this, v)
        if (!partContext) {
          // throw new Error(`no partContext`)
          return undefined
        }
        return dxEval(v, partContext, this)
      }


      let parts = {}
      config.parts.forEach(part => {
        parts[part.name] = initPart(part)
      })

    // async function callCom(partKey, methodName, ...args) {
    //   let part = parts[partKey]
    //   if (!part.el ) {
    //     throw new Error('formCom.value null')
    //   }
    //   // console.log(partKey, parts, part.el)
    //   let elRef = part.el.value
    //   if (!elRef) {
    //     throw new Error('formCom.value null')
    //   }
    //   return await ZY.awaitTo(elRef[methodName](...args))
    // }

    function z_get(obj, p, defaultVal) {
      let ret = ZY.lodash.get(obj, p, defaultVal)
      if (ret === '') {
        return defaultVal
      }
      return ret
    }

    let instanse = {
      config,
      parts,
      defaultTo: ZY.lodash.defaultTo,
      z_get,
      get: ZY.lodash.get,
      dxValue,
      // dxEval,
    };

    instanse.slotContent = (function() {
      if (props.render) {
        return props.render()
      }
      return {
        default: []
      }
    })()


    // instanse.getState = function(partKey = '') {
    //   let ret = parts[partKey]
    //   let res = {}
    //   for (let k in ret.model) {
    //     res[k] = ret.model[k]
    //   }
    //   for (let k in ret.computedModel) {
    //     res[k] = ret.computedModel[k].value
    //   }
    //   return {
    //     val: res,
    //     toRaw() {
    //       return ZY.JSON5.parse(ZY.JSON5.stringify(res))
    //     }
    //   }
    // }
    //
    // instanse.getRawState = function(...args) {
    //   return instanse.getState(...args).toRaw()
    // }

    return instanse
  },
};
</script>
